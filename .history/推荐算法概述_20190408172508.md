## 推荐系统

**背景**；随着互联网的发展，人们逐渐从信息匮乏的时代走入了信息过载的时代，面对海量的信息，用户很难找到自己真正感兴趣的。一个著名的解决方案是搜索引擎技术，用户只需要输入关键字就能得到想要的信息。但很多时候用户的需求并不明确，比如，用户某天因为无聊想看电影，但没有具体的目标，面对着上百年来的无数电影，用户只觉手足无措。而推荐系统能够自动地为用户发现他们可能感兴趣的信息，同时解决信息过载和用户实际需求不明确的问题。

**推荐系统的优势**：在互联网领域发掘长尾分布中的巨大市场（长尾分布：大部分用户需求都集中在头部流行的物品，但分布在尾部的个性化需求利润小但总量更大）对于用户，一千个读者就有一千个哈姆雷特。推荐系统的出现，让每个用户都能拥有私人订制的体验，快速发现自己真正感兴趣的物品。对于内容提供者来说，保证自己生产的每个内容都能被用户所发现。

**推荐系统的应用**：被广泛应用于社交、电子商务、信息流产品、音乐、电影、广告投放等，任何需要提供个性化服务的场景。

### 推荐算法的原理

要搞清楚推荐系统是如何工作的，我们首先回顾一下现实生活中用户在面对很多选择时时如何做出决定的。仍然以看电影为例，一般来说我们可能以如下方式决定最终看什么电影：

1. 向朋友咨询。我们可能会向平时经常看电影的朋友咨询，询问他们的意见，或者在社交平台上发一句“我要看电影的动态”，等待热心网友的推荐。这种方式在推荐系统中被称作**社交化推荐**。
   
2. 我们一般有自己偏爱的导演或者演员，有些人也会有自己偏爱的题材，这时通常的做法是打开一个搜索引擎，寻找这些人导演过或者出演过的电影，或者寻找某个类别下的电影，看看有没有自己感兴趣的。推荐系统将这一过程自动化，在推荐系统中被称作**基于内容的推荐**。

3. 我们还可能查看排行榜，比如豆瓣电影top250。看看大家都喜欢哪些电影，然后找一部广受好评的电影进行观看。但这种方式只能推荐流行的电影缺乏个性，可以进一步扩展，找到和自己历史兴趣相似的用户，看看他们看过的电影，这种方式通常比宽泛的热门排行榜更能符合用户的兴趣，被称为**基于协同过滤的推荐**

从上面的实例可以看出，**推荐系统的本质**是通过各种方式将用户和特定的物品联系起来。和搜索引擎不同，个性化推荐系统不需要顾客主动输入，只需要用户的行为数据和历史信息。

### 推荐算法的评价标准
![](imgs/1.png)

这里重点关心离线评测的方法。四个评价标准中，用户满意度的获取一般通过在线的方式获取，在离线测试时通常使用前三个指标，现在分别对三个指标进行介绍：

#### 1. 预测准确度

预测准确度是衡量一个推荐系统预测用户行为的能力，是一个推荐系统中最重要的指标，可以通过离线的实验进行计算。

在计算该指标时需要一个离线的数据集，其中包含用户的历史行为记录，然后将该数据集划分成训练集和测试集，在训练集上训练模并预测用户在测试集上的行为，计算预测行为和测试集上行为的重合度作为预测的准确度。

衡量预测准确度时，不同的推荐方式有不同的评价标准，这里分别介绍基于评分预测和基于TopN推荐的不同评价方式。

**评分预测**

如果知道用户对物品的历史评分，训练模型预测该用户对没有评过分的物品的评分，这种推荐方式称为评分预测。

基于评分预测的推荐系统的准确度一般通过 RMSE 和 MAE计算，二者仅仅是计算预测误差时的方式不同。

对于测试集中的用户u和物品i，$r_{ui}$是用户u对物品i的实际评分，$\hat r_{ui}$是推荐系统给出的预测评分。

其中RMSE的定义为：
$$
RMSE = \sqrt{\frac{\sum_{u,i \in T} (r_{ui}- \hat r_{ui})^2}{\vert T \vert}}
$$

MAE的定义为：

$$
MAE = {\frac{\sum_{u,i \in T} \vert r_{ui}- \hat r_{ui}\vert}{\vert T \vert}}
$$

如果评分系统是基于整数建立的，即用户的评分只能是整数，那么对预测结果取整可以降低MAE的误差。

**TopN推荐**

在做推荐时，按照模型预测的用户对物品的感兴趣程度，给用户一个排过序的个性化推荐列表，这种方式被称作TopN推荐。这种推荐方式的预测准确度通常通过准确率和召回率进行度量。

如果R(u)是根据用户在训练集上的行为给用户做出的推荐列表，而T(u)是用户在测试集上的行为列表。

**准确率**：衡量预测正确的用户行为占总的用户行为的比例,定义为：

$$
precision = \frac{ \sum_{u \in U} \vert R(u) \cap T(u)  \vert}{ \sum_{u \in U} \vert R(u) \vert}
$$

**召回率**：衡量有多少测试集中的用户行为被系统成功预测出来,定义为：

$$
recall = \frac{ \sum_{u \in U} \vert R(u) \cap T(u)  \vert}{ \sum_{u \in U} \vert T(u) \vert}
$$

有的时候为了全面评测系统的准确率和召回率，一般会选取不同的推荐列表长度N，计算出每组的准确率和召回率，画出P-R曲线(准确率/召回率曲线)

```python
'''
test: 测试使用的用户行为数据 {user_id:[items]}
get_recommendation:传入用户编号和超参，返回推荐列表

return （precision, recall） 当前模型的准确率和召回率
'''
def precesion_and_recall(test, get_recommondation):
    hit = 0
    n_precision = 0
    n_recall = 0
    for user, items in test.items():
        rank = set(get_recommondation(user))
        hit += len(rank & set(items))
        n_precision += len(rank)
        n_recall += len(items)
    return hit/(1.0 * n_precision), hit/(1.0 * n_recall)
```

> **关于评分预测和TopN推荐的讨论**
评分预测一直是推荐系统研究的热点，大多数的推荐系统的理论研究都是基于用户的评分·数据，这主要是由于早期的推荐系统研究都是基于用户评分的(著名的movieLens和Netfix比赛数据)，因此很多研究人员都将研究精力集中在优化评分预测的RMSE和MAE上。
但是近年来有专家指出：推荐系统的目的是找到用户可能感兴趣的电影，而不是找到用户看完电影后，可能会给电影评多少分，也许有一部电影，用户看完后会给很高的分数，但是用户会看的可能性非常小，因此，预测用户是否会看一部电影比预测用户看完电影后会给电影评多少分更重要。
在实际的产品使用中，用户的行为数据很多时候都不是明确的评分数据，例如一个音乐应用中，用户不可能对自己听过的每一首歌进行评分。TopN推荐相对于评分预测更符合实际的推荐需求。

#### 2. 覆盖率

覆盖率是一个内容提供商最为关心的指标，它描述一个推荐系统对物品长尾的发掘能力，最简单的定义是推荐系统中能够推荐出来的物品占总物品的比例。

假设用户的集合为U，推荐系统给每个用户推荐一个长度为N的物品列表R(u).那么推荐系统的覆盖率可以通过下面的公式计算：

$$
Coverage = \frac{\vert\bigcup_{u \in U } R(u)\vert}{I}
$$

以图书推荐为例，图书供应商会很关心他们的书有没有推荐给用户。一个覆盖率为100%的推荐系统会把每个物品都推荐给用户。从上面的定义也可以看出，热门排行榜的推荐覆盖率非常低。一个好的推荐系统除了要用户满意，也要有较高的覆盖率。

``` python
'''
train: 训练使用的用户行为数据
get_recommendation:传入用户编号和超参，返回推荐列表

return 当前模型的覆盖率
'''

def coverage(train, get_recommendation):
    all_items = set()
    recommend_items = set()
    for user, items in train.items():
        recommend_item = get_recommendation(user_row)
        recommend_items.add(recommend_item)
        all_items.add(items)
    return len(recommend_items) / (all_items_len * 1.0)

```

#### 3. 新颖度

最后我们还要评价推荐的新颖度，这里用推荐列表中物品的平均流行度度量推荐结果的新颖度。也就是说如果推荐出的物品都很热门，说明推荐的新颖度很低，反之则说明推荐的结果比较新颖。

```python
'''
train_matrix: 训练使用的用户行为
get_recommendation:传入用户编号和超参，返回推荐列表

return 当前模型的平均流行度
'''
def popularity(train, get_recommendation):
    # 获取每个物品的流行度
    item_popularity= {}
    for user, items in train.items():
        for item in items:
            if item not in item_popularity:
                item_popularity[item] = 0
            item_popularity[item] += 1
    ret = 0
    n = 0
    # 获取推荐物品总的流行度
    for user in train.keys():
        rank = get_recommendation(user)
        for item in rank:
            ret += math.log(1 + item_popularity[item])
            n += 1
    return ret/(n * 1.0)
```
在这里计算流行度时对每个物品的流行度取对数，这时因为物品的流行度分布满足长尾分布，取对数后，流行度的平均值更加稳定。

### 用户行为数据

分析用户行为进行推荐的算法是个性化推荐系统中一个非常重要的算法，学术上把这种类型的算法称作协同过滤算法。顾名思义，协同过滤就是指用户可以齐心协力，通过不断的和网站互动，使得自己的推荐列表能够不断过滤掉自己不感兴趣的物品。从而越来越满足用户的需求。

用户行为数据最简单的**存在形式**就是日志，服务器中的日志系统会记录用户的各种行为，包括网页浏览，点击，购买，评分和评论等。

用户行为在个性化推荐系统中分为：**隐式反馈行为**和**显式反馈行为**。评分数据是最典型的显示反馈行为。这种类型的行为数据能够明确表示出用户对物品的喜好程度。与之相对应的就是隐性反馈行为，其中最具代表性的就是用户的浏览行为。

**用户行为的统一表示**：
标识| 含义
--- | ---
user id | 产生行为的用户的唯一标识
item id | 产生行为的对象的唯一标识
behavior type | 行为的种类 比如是购买还是浏览
context | 产生行为的上下文，包括时间和地点等
behavior weight | 行为的权重 比如观看视频的时长，评分行为的分数
behavior content | 行为的内容，如果是评论行为就是评论的文本

代表性的行为数据集有如下几个：

1. 无上下文信息的隐性反馈数据集，每一条记录仅包含用户id和物品id
2. 无上下文信息的显性反馈数据集，每一条记录包含用户id、物品id和用户对物品的评分
3. 有上下文信息的隐性反馈数据集，每一条记录包含用户id、物品id和对物品产生行为的时间戳或地理信息
4. 有上下文信息的显性反馈数据集，每一条记录仅包含用户id，物品id、用户对物品对评分，评分行为产生的时间戳或地理信息


